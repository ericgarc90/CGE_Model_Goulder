# -*- coding: utf-8 -*-
"""Simulation - Search.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eKiJvM5p6Vl8fxwKYsriyB1HwpBKX6B2
"""


## Now to do is to implement Larry's new changes


import numpy as np
from scipy.optimize import least_squares
from tabulate import tabulate
import csv
import os

##Reading input data
## Parameters
b = 15.9 #emissions factor
a_lg = 0.8666148231643368 #share parameter for labor into G
a_kg = 0.1333851768356632 #share parameter for capital into G

a_lx = 0.7277775876801069 #share parameter for labor into X
a_kx = 0.2722224123198931 #share parameter for capital into X

a_ly = 0.528113693661505 #share parameter for labor into Y
a_ky = 0.3788419322453242 #share parameter for capital into Y
a_fy = 0.093044374093170 #share parameter for emissions into Y

a_xz = 0.8256357034812283 #share parameter for X into Z
a_yz = 0.17436429651877172 #share parameter for Y into Z

a_zu = 0.7467 #share parameter for Z into U
a_gu = 0.2533 #share parameter for G into U

gamma_x = 1.6277684753381738
gamma_g = 1.925514327210921
gamma_y = 1.4887099854907326

gamma_z = 1.0903544262527596

L0_v = 180 #total value of labor 
K0_v = 85 #total value of capital

G = 60 + 20 #total amount of government good
F0 = 5 #total amount of emissions

t_l = 0.4 #labor tax
t_k = 0.2 #capital tax
t_f = 0 #fuel tax

X0q = 150
Y0q = 40 
G0q = 80

sig_X = 0.65
sig_Y = 0.75
sig_G = 0.55
sig_Z = 0.85

L0 = L0_v/(1 + t_l)
K0 = K0_v/(1 + t_k)

LXv_0 = 100
KXv_0 = 50

LYv_0 = 20
KYv_0 = 15
FYv_0 = 5

LGv_0 = 60
KGv_0 = 20

LXq_0 = LXv_0/(1 + t_l)
KXq_0 = KXv_0/(1 + t_k)


LYq_0 = LYv_0/(1 + t_l)
KYq_0 = KYv_0/(1 + t_k)
FYq_0 = FYv_0/(1 + t_f)

LGq_0 = LGv_0/(1 + t_l)
KGq_0 = KGv_0/(1 + t_k)


#X0q = LXv_0/(1 + t_l) + KXv_0/(1 + t_k)

T = -14.4048



print(L0)
print(K0)
print(f'the sum of G share parameters are : {a_lg +a_kg}')
print(f'the sum of X share parameters are : {a_lx +a_kx}')
print(f'the sum of Y share parameters are : {a_ly +a_ky +a_fy}')
print(f'the sum of Z share parameters are : {a_xz +a_yz}')

### Setting guesses for 
"""w = 1 #wage rate
r = 1 #capital rate
v = 1 #price of fuel
ty = 0 #ad valorem tax on good Y
tx = 0
tF = 0 #emissions tax (unit tax)
# tx = 0 # when will we need to use tax on good X?
dT = 0 #additional lumpsum transfer adjustment
dM = 1 #multiplicative factor applied to labor and capital tax
E_lim = 79.5"""

### Calculating prices for X and Y as a function of w, r and t_E


def p_X(r, w, tx):
    w_tax = w*(1 + dM*t_l)
    r_tax = r*(1 + dM*t_k)

    first_term = (a_kx**sig_X)*(r_tax)**(1-sig_X)
    second_term = (a_lx**sig_X)*(w_tax)**(1-sig_X)
    
    pX = gamma_x**(sig_X/(sig_X-1))*(first_term + second_term)**(1/(1-sig_X))*(1-tx)
    
    ## a_kx, a_lx are share parameters that add to 1
    ## sig_X is the elasticity of substitution between K and L in production of X
    ## gamma_x is derived from calibration to ensure zero economic profits
    
    return pX
    
def p_Y(r, w, v, tF, ty):
    w_tax = w*(1 + dM*t_l)
    r_tax = r*(1 + dM*t_k)

    first_term = (a_ky**sig_Y)*((r_tax)**(1-sig_Y))
    second_term = (a_ly**sig_Y)*((w_tax)**(1-sig_Y))
    third_term = (a_fy**sig_Y)*((tF + v)**(1-sig_Y))
    
    pY = gamma_y**(sig_Y/(sig_Y-1))*((first_term + second_term + third_term)**(1/(1-sig_Y)))*(1-ty)
    
    ## a_Ky, a_Ly are share parameters that add to 1
    ## sig_Y is the elasticity of substitution between K and L in production of Y
    ## tE is the pre-set carbon tax. eta is the BAU price of emissions which will be zeroed out
    ## ty is the output tax
    ## gamma_y is derived from calibration to ensure zero economic profits
    
    return pY

def p_G(w, r):
    w_tax = w*(1 + dM*t_l)
    r_tax = r*(1 + dM*t_k)

    first_term = (a_kg**sig_G)*(r_tax)**(1-sig_G)
    second_term = (a_lg**sig_G)*(w_tax)**(1-sig_G)
    
    pg = gamma_g**(sig_G/(sig_G-1))*(first_term + second_term)**(1/(1-sig_G))
    
    ## a_Kg, a_Lg are share parameters that add to 1
    ## sig_G is the elasticity of substitution between K and L in production of G
    ## gamma_g is derived from calibration to ensure zero economic profits
    return pg

#pg = p_G(w, r)
#px = p_X(w, r, tx)
#py = p_Y(w, r, v, tF, ty)    

"""print(f'The simulation price of X is p_X = {px}')

print(f'The simulation price of Y is p_Y = {py}')

print(f'The simulation price of G is p_G = {pg}')

"""

#### Defining Optimal Quantities


def L_X(w, px, r):
    w_tax = w*(1 + dM*t_l)
    r_tax = r*(1 + dM*t_k)
    lx = ((a_lx/gamma_x)**sig_X)*((w_tax/px)**(-sig_X))
    
    ## a_Lx is the share parameter
    ## sig_X is the elasticity of substitution
    ## w is the wage
    ## px is the calculated price of good X
    ## X is the quantity of good X
    ## lx is the optimal quantity of labor in good X
    return lx 

def K_X(w, px, r):
    w_tax = w*(1 + dM*t_l)
    r_tax = r*(1 + dM*t_k)
    kx = ((a_kx/gamma_x)**sig_X)*((r_tax/px)**(-sig_X))
    
    ## a_kX is the share parameter
    ## sig_X is the elasticity of substitution
    ## r is return to capital
    ## px is the calculated price of good X
    ## X is the quantity of good X
    ## kx is the optimal quantity of captial in good X
    return kx 


def L_Y(w, py, r):
    w_tax = w*(1 + dM*t_l)
    r_tax = r*(1 + dM*t_k)
    ly = ((a_ly/gamma_y)**sig_Y)*((w_tax/py)**(-sig_Y))
    
    ## a_Ly is the share parameter
    ## sig_Y is the elasticity of substitution
    ## w is the wage
    ## p is the calculated price of good Y
    ## Y is the quantity of good Y
    ## ly is the optimal quantity of labor in good Y
    return ly

def K_Y(w, py, r):
    w_tax = w*(1 + dM*t_l)
    r_tax = r*(1 + dM*t_k)
    ky = ((a_ky/gamma_y)**sig_Y)*((r_tax/py)**(-sig_Y))
    
    ## a_kY is the share parameter
    ## sig_Y is the elasticity of substitution
    ## r is return to capital
    ## py is the calculated price of good Y
    ## Y is the quantity of good Y
    ## ky is the optimal quantity of captial in good Y
    return ky
    
def F_Y(w, r, tf, py, v):
    w_tax = w*(1 + dM*t_l)
    r_tax = r*(1 + dM*t_k)
    ey = ((a_fy/gamma_y)**sig_Y)*((tf + v)/py)**(-sig_Y)

    ## a_E is the share parameter
    ## sig_Y is the elasticity of substitution
    ## pe is the price of emissions
    ## py is the calculated price of good Y
    ## Y is the quantity of good Y
    ## ey is the optimal quantity of emissions in good Y
    return ey



def L_G(w, pg, r):
    w_tax = w*(1 + dM*t_l)
    r_tax = r*(1 + dM*t_k)
    lg = ((a_lg/gamma_g)**sig_G)*((w_tax/pg)**(-sig_G))
    
    ## a_Lg is the share parameter
    ## sig_G is the elasticity of substitution
    ## w is the wage
    ## pg is the calculated price of good G
    ## G is the quantity of good G (fixed)
    ## lg is the optimal quantity of labor in good G
    ## gamma_g is derived from calibration to ensure zero economic profits
    return lg 

def K_G(w, pg, r):
    w_tax = w*(1 + dM*t_l)
    r_tax = r*(1 + dM*t_k)
    kg = ((a_kg/gamma_g)**sig_G)*((r_tax/pg)**(-sig_G))
    
    ## a_kg is the share parameter
    ## sig_G is the elasticity of substitution
    ## r is return to capital
    ## pG is the calculated price of good G
    ## G is the quantity of good G
    ## kg is the optimal quantity of captial in good G
    ## gamma_g is derived from calibration to ensure zero economic profits
    return kg     

def optimal_lk_x(w, r, px, tl, tk):
 
  lx = L_X(w, px, r) 
  kx = K_X(w, px, r) 
  return lx, kx

def optimal_lkf_y(w, r, v, py, tf, tl ,tk):
 
  ly = L_Y(w, py, r) 
  ky = K_Y(w, py, r)
  fy = F_Y(w, r, tf, py, v) 
  return ly, ky, fy 

def optimal_lk_g(w, r, pg, tl , tk):

  lg =  L_G(w, pg, r) 
  kg = K_G(w, pg, r) 
  return lg, kg  



  ##calculates all the optimal intensities for goods X, Y, G from labor, capital

#optimal_lkx = optimal_lk_x(w, r, px, t_l, t_k)
#optimal_lkfy = optimal_lkf_y(w, r, v, py, tF, t_l, t_k)
#optimal_lkg = optimal_lk_g(w, r, pg, t_l, t_k)

"""print(f'Simulated LX/X = {np.round(optimal_lkx[0], 4)}')
print(f'Calibrated LX/X = {np.round(LXq_0/X0q, 4)}')
print(f'Simulated KX/X = {np.round(optimal_lkx[1], 4)}')
print(f'Calibrated KX/X = {np.round(KXq_0/X0q, 4)}')

print('')
print(f'Simulated LY/Y = {np.round(optimal_lkfy[0], 4)}') 
print(f'Calibrated LY/Y = {np.round(LYq_0/Y0q, 4)}') 

print(f'Simulated KY/Y = {np.round(optimal_lkfy[1], 4)}') 
print(f'Calibrated KY/Y = {np.round(KYq_0/Y0q, 4)}') 
print(f'Simulated FY/Y = {np.round(optimal_lkfy[2], 4)}') 
print(f'Calibrated KY/Y = {np.round(FYq_0/Y0q, 4)}') 
print('')

print(f'Simulated LG/G = {np.round(optimal_lkg[0], 4)}')
print(f'Calibrated LG/G = {np.round(LGq_0/G0q, 4)}') 
print(f'Simulated KG/G = {np.round(optimal_lkg[1], 4)}')
print(f'Calibrated KG/G = {np.round(KGq_0/G0q, 4)}') """

def p_Z(px, py):
    
    first_term = (a_xz**sig_Z)*px**(1-sig_Z)
    second_term = (a_yz**sig_Z)*py**(1-sig_Z)
    
    pZ = gamma_z**(sig_Z/(sig_Z-1))*(first_term + second_term)**(1/(1-sig_Z))
  
    return pZ

#pz = p_Z(px, py)    
#print(f'The simulation price of Z is p_Z = {pz}')

###optimal quantities of X and Y into Z


def X_Z(px, pz):
    
    xz = ((a_xz/gamma_z)**sig_Z)*((px/pz)**(-sig_Z))
    
    return xz 

  ## a_xz is the share parameter of X into Z


def Y_Z(py, pz):
    
    yz = ((a_yz/gamma_z)**sig_Z)*((py/pz)**(-sig_Z))
    
    return yz
  ## a_yz is the share parameter of Y into Z

def opt_xyz_ratios(px, py, pz):
  #denom = X_Z(px, pz) + Y_Z(py, pz)
  opt_xz = X_Z(px, pz)
  opt_yz = Y_Z(py, pz)
  
  return opt_xz, opt_yz

#optimal_xyz_ratios = opt_xyz_ratios(px, py, pz)

"""print(f'Simulated X/Z = {np.round(optimal_xyz_ratios[0], 4)}')
print(f'Simulated Y/Z = {np.round(optimal_xyz_ratios[1], 4)}')
print('')

print(f'Calibrated X/Z = {np.round(X0q/(Y0q + X0q), 4)}')
print(f'Calibrated Y/Z = {np.round(Y0q/(Y0q + X0q), 4)}')
"""

### Calculating Z according to the HH budget

def Z_quant(w, r, v, pz, dt, s):
  w_tax = w*(1 + dM*t_l)
  r_tax = r*(1 + dM*t_k)
  lab_inc = w*L0
  cap_inc = r*K0
  fuel_inc = v*F0*s
  transfer = T + (dt - 0)
  numerator  = lab_inc + cap_inc + fuel_inc + transfer
  Z = numerator/pz

  """  print(f'income from labor = {lab_inc}')
  print(f'income from capital = {cap_inc}')
  print(f'income from fuel = {fuel_inc}')
  print(f'income from lumpusm transfer = {-transfer}')
  """
  
  return Z, lab_inc, cap_inc, transfer, fuel_inc

#Z_q = Z_quant(w, r, v, pz)
#Z_q
#print(f'Z = {np.round(Z_q[0], 4)}')

## Calculating the optimal quantities of X and Y
def opt_xz_quant(xyz_ratios, Zq):

  X_q = Zq[0]*xyz_ratios[0]
  Y_q = Zq[0]*xyz_ratios[1]

  #print(f'X_q = {np.round(X_q, 4)}')
  #print(f'Y_q = {np.round(Y_q, 4)}')
  return X_q, Y_q

#X_quant, Y_quant = opt_xz_quant(optimal_xyz_ratios, Z_q)

### Calculating capital, labor, and emissions demands
def LKF_demands(LKX_opt, LKFY_opt, LKG_opt, Xq_opt, Yq_opt, Gq): ## the inputs are the optimal ratios for 
  L_K_X_quant = Xq_opt*np.asarray(LKX_opt)
  LXq = L_K_X_quant[0]
  KXq = L_K_X_quant[1]

  L_K_F_Y_quant = (Yq_opt)*np.asarray(LKFY_opt)
  LYq = L_K_F_Y_quant[0]
  KYq = L_K_F_Y_quant[1]
  FYq = L_K_F_Y_quant[2]


  L_K_G_quant = Gq*np.asarray(LKG_opt)
  LGq = L_K_G_quant[0]
  KGq = L_K_G_quant[1]

  """  print(f'LX_q = {LXq}')
  print(f'KX_q = {KXq}')

  print(f'LY_q = {LYq}')
  print(f'KY_q = {KYq}')
  print(f'FY_q = {FYq}')

  print(f'LG_q = {LGq}')
  print(f'KG_q = {KGq}')"""

  return LXq, KXq, LYq, KYq, FYq, LGq, KGq
#LXq, KXq, LYq, KYq, FYq, LGq, KGq = LKF_demands(optimal_lkx, optimal_lkfy, optimal_lkg, X_quant, Y_quant, G)

def simulated_XYG(LXq, KXq, LYq, KYq, FYq, LGq, KGq, tl, tk, dm):

  Xq_sim = LXq + KXq
  Yq_sim = LYq + KYq + FYq
  Gq_sim = LGq*(1+tl*dm) + KGq*(1+tk*dm)

  """  print(f'Sum of Lq and Kq into X = {Xq_sim}')
    print(f'Sum of Lq, Kq and F into Y = {Yq_sim}')
    print(f'Sum of Lq and Kq into G = {Gq_sim}')
  """
  return Xq_sim, Yq_sim, Gq_sim

#Xq_sim, Yq_sim, Gq_sim = simulated_XYG(LXq, KXq, LYq, KYq, FYq, LGq, KGq)

##taxes paid
def taxes_paid(LXq, KXq, LYq, KYq, FYq, LGq, KGq, tF, s):

  LX_tax = LXq*t_l*dM 
  KX_tax = KXq*t_k*dM

  LY_tax = LYq*t_l*dM
  KY_tax = KYq*t_k*dM
  FY_tax = FYq*tF #F0*s*tF

  LG_tax = LGq*t_l*dM 
  KG_tax = KGq*t_k*dM

  L_taxes = LX_tax + LY_tax + LG_tax
  K_taxes = KX_tax + KY_tax + KG_tax

  """print(f'LX_tax= {LX_tax}')
  print(f'KX_tax= {KX_tax}')
  print(f'LY_tax= {LY_tax}')
  print(f'KY_tax= {KY_tax}')
  print(f'FY_tax= {FY_tax}')
"""
  X_taxes = LX_tax + KX_tax
  Y_taxes = LY_tax + KY_tax + FY_tax
  G_taxes = LG_tax + KG_tax
  #print(f'Total X taxes = {X_taxes}')
  #print(f'Total Y taxes = {Y_taxes}')

  return L_taxes, K_taxes, FY_tax
#L_taxes, K_taxes, F_tax = taxes_paid(LXq, KXq, LYq, KYq, FYq, LGq, KGq)

### calculating gov budget
def gov_budget(Ltax, Ktax, Ftax, Xq, Yq, Gq, px, py, pg, w, r, dt):
  gov_exp = pg*G
  gov_rev = -(T + (dt)) + tx*Xq*px + ty*Yq*py + Ftax + Ltax*w + Ktax*r      
  return gov_exp, gov_rev

#gov_exp, gov_rev = gov_budget(L_taxes, K_taxes, F_tax, Xq_sim, Yq_sim, Gq_sim, px, py, pg, w, r )

#%%capture cap --no-stderr

### Simulation Program for Emissions Standard
# This runs the simulation program and has inputs labor price (w), capital returns rate (r),
# fuel tax (tF), change to lumpsum transfer (dT), multiplicative factor change to capital and labor taxes
# and the Emissions limit

def sim_inner(inputs, v, ty, tx, tF):

  """Step 1: Calling functions that calculate the prices of G, X, and Y"""
  w = 1
  r = inputs[0]
  dT = inputs[1] - 1 
  s = inputs[2]

  pg = p_G(w, r) #calls function that calculates the price of G
  pg_0 = p_G(1, 1) #calculates baseline price of government good
  px = p_X(w, r, tx) #calls function that calculates the price of X
  px_0 = p_X(1, 1, 0) #calculates baseline price of good X
  py = p_Y(w, r, v, tF, ty) #calls function that calculates the price of Y
  py_0 = p_Y(1, 1, 1, 0, 0) #calculates baseline price of good Y
  
  """Step 2: Calling funtions that calculate the optimal intensities of labor
  capital, and fuel into X, Y and G """

  optimal_lkx = optimal_lk_x(w, r, px, t_l, t_k) #calls function that calculates optimal intensities of L and K into X
  optimal_lkx_0 = optimal_lk_x(1, 1, px_0, t_l, t_k) #baseline lxk ratio
  optimal_lkfy = optimal_lkf_y(w, r, v, py, tF, t_l, t_k) #calls function that calculates optimal intensities of L, K, and F into Y
  optimal_lkfy_0 = optimal_lkf_y(1, 1, 1, py_0, 0, t_l, t_k) #baseline lkfy ratio
  optimal_lkg = optimal_lk_g(w, r, pg, t_l, t_k) #calls function that calculates optimal intensities of L and K into G
  optimal_lkg_0 = optimal_lk_g(1, 1, pg_0, t_l, t_k) #baseline lkg ratio

  """ Step 3: Calls function that calculates the price of Z"""
    
  pz = p_Z(px, py) #calls function that calculates the price of Z
  pz_0 = p_Z(px_0, py_0) #baseline price of composite good Z
  
  """Step 4: Calls function that calculates the optimal intensities of X and Y into Z """

  optimal_xyz_ratios = opt_xyz_ratios(px, py, pz) #calls function that calculatees the optimal intensities of X and Y into Z
  optimal_xyz_ratios_0 = opt_xyz_ratios(px_0, py_0, pz_0) #baseline optimal ratios of x and y into z
  """Step 5: Calls function that calculate the amount of Z according to the HH budget"""
    
  Z_q = Z_quant(w, r, v, pz, dT, s) #calls function that calculates the quantity of Z
  Z_q0 = Z_quant(1, 1, 1, pz_0, 0, 1) #baseline quantity of Z

  """Step 6: Calls function that calculates the quantities of X and Y as dictated
  by the Z that meets the HH budget and the the optimal intensities of X/Z and Y/Z"""

  X_quant, Y_quant = opt_xz_quant(optimal_xyz_ratios, Z_q) #assigns output of function opt_xz_quant to variables X_quant and Y_quant 
  X_quant_0, Y_quant_0 = opt_xz_quant(optimal_xyz_ratios_0, Z_q0) #baseline measures of X quant and Y quant

  """Step 7: Calls function that calculates the quantities of L into X, Y, and G.
  K into X, Y, and G, and F into Y.  """

  LXq, KXq, LYq, KYq, FYq, LGq, KGq = LKF_demands(optimal_lkx, optimal_lkfy, optimal_lkg, X_quant, Y_quant, G)  
  LXq0, KXq0, LYq0, KYq0, FYq0, LGq0, KGq0 = LKF_demands(optimal_lkx_0, optimal_lkfy_0, optimal_lkg_0, X_quant_0, Y_quant_0, G)  

  """Step 8: Calculating excess demands for Labor and Capital"""
  
  L_demand = LXq + LYq + LGq
  L_demand_0 = LXq_0 + LYq_0 + LGq_0
  L_excess = (L_demand - L0)/L0 
  L_excess_0 = (L_demand_0 - L0)/L0

  
  K_demand = KXq + KYq + KGq
  K_demand_0 = KXq_0 + KYq_0 + KGq_0
  K_excess = (K_demand - K0)/K0 ## if going right, these should be getting close to zero
  K_excess_0 = (K_demand_0 - K0)/K0

  F_excess_0  = (FYq0 - F0)/F0
  F_excess  = (FYq - s*F0)/F0

  """Step 9: Calculating excess demand for government expenditure and revenue"""

  L_taxes, K_taxes, F_tax = taxes_paid(LXq, KXq, LYq, KYq, FYq, LGq, KGq, tF, s)
  L_taxes_0, K_taxes_0, F_tax_0 = taxes_paid(LXq0, KXq0, LYq0, KYq0, FYq0, LGq0, KGq0, 0, 1)

  Xq_sim, Yq_sim, Gq_sim = simulated_XYG(LXq, KXq, LYq, KYq, FYq, LGq, KGq, t_l, t_k, dM)
  Xq_sim_0, Yq_sim_0, Gq_sim_0 = simulated_XYG(LXq0, KXq0, LYq0, KYq0, FYq0, LGq0, KGq0, t_l, t_k, 1)
  
  gov_exp, gov_rev = gov_budget(L_taxes, K_taxes, F_tax, Xq_sim, Yq_sim, Gq_sim, px, py, pg, w, r, dT ) #calls function that calculates the values needed to evaluate the gov spending excess condiditon
  gov_exp_0, gov_rev_0 = gov_budget(L_taxes_0, K_taxes_0, F_tax_0, Xq_sim_0, Yq_sim_0, Gq_sim_0, px_0, py_0, pg_0, 1, 1, 0 )
  
  gov_excess = (gov_rev - gov_exp)/G
  gov_excess_0 = (gov_rev_0 - gov_exp_0)/G

  sum_excess_demands_0 = L_excess_0*L0 + K_excess_0*K0 + F_excess_0*F0 + gov_excess_0*G
  sum_excess_demands = L_excess*L0 + K_excess*K0 + F_excess*F0 + gov_excess*G

  w_tax = w*(1 + dM*t_l)
  r_tax = r*(1 + dM*t_k)
  v_tax = v*(1 + tF)

  walras = np.round(w_tax*L_excess*L0 + r_tax*K_excess*K0 + gov_excess*G + v_tax*F_excess*F0, 4)

  walras_0 = np.round(1*(1 + t_l)*L_excess_0*L0 + 1*(1 + t_k)*K_excess_0*K0 + gov_excess_0*G + 1*F_excess_0*F0, 4)

  total_inc_0 = Z_q0[1] + Z_q0[2] + Z_q0[3] + Z_q0[4]
  total_inc = Z_q[1] + Z_q[2] + Z_q[3] + Z_q[4]
 
  X_exp  = px*X_quant
  X_exp_0 = px_0*X_quant_0

  Y_exp  = py*Y_quant
  Y_exp_0 = py_0*Y_quant_0

  total_exp = Y_exp + X_exp
  total_exp_0 = Y_exp_0 + X_exp_0

  fuel_elasticity = (F0 - s*FYq)/(1 - (v + tF))
  

  price_table = [['Variable', 'Benchmark', 'Policy', 'Diff (P-B)'],
                 ['p_X', np.round(px_0, 4) , np.round(px, 4), np.round(px - px_0, 4)],
                 ['p_G', np.round(pg_0, 4), np.round(pg, 4), np.round(pg - pg_0, 4)],
                 ['p_Y', np.round(py_0, 4), np.round(py, 4), np.round(py - py_0, 4)],
                 ['p_Z', np.round(pz_0, 4), np.round(pz, 4), np.round(pz - pz_0, 4)]]


  LKF_opt_table = [['Variable', 'Benchmark', 'Policy', 'Diff (P-B)'],
                   ['opt intensity LX', np.round(optimal_lkx_0[0], 4), np.round(optimal_lkx[0], 4), np.round(optimal_lkx[0] - optimal_lkx_0[0], 4)],
                   ['opt intensity KX', np.round(optimal_lkx_0[1], 4), np.round(optimal_lkx[1], 4), np.round(optimal_lkx[1] - optimal_lkx_0[1], 4)],
                   ['intensity LX/KX', np.round(optimal_lkx_0[0]/optimal_lkx_0[1], 4), np.round(optimal_lkx[0]/optimal_lkx[1], 4),
                    np.round((optimal_lkx[0]/optimal_lkx[1]) - (optimal_lkx_0[0]/optimal_lkx_0[1]), 4)],
           
                  ['opt intensity LY', np.round(optimal_lkfy_0[0], 4), np.round(optimal_lkfy[0], 4), np.round(optimal_lkfy[0] - optimal_lkfy_0[0], 4)],
                  ['opt intensity KY', np.round(optimal_lkfy_0[1], 4), np.round(optimal_lkfy[1], 4), np.round(optimal_lkfy[1] - optimal_lkfy_0[1], 4)],
                  ['opt intensity FY', np.round(optimal_lkfy_0[2], 4), np.round(optimal_lkfy[2], 4), np.round(optimal_lkfy[2] - optimal_lkfy_0[2], 4)],
                  ['intensity LY/KY', np.round(optimal_lkfy_0[0]/optimal_lkfy_0[1], 4), np.round(optimal_lkfy[0]/optimal_lkfy[1], 4),
                    np.round((optimal_lkfy[0]/optimal_lkfy[1]) - (optimal_lkfy_0[0]/optimal_lkfy_0[1]), 4)],
           
                  ['opt intensity LG', np.round(optimal_lkg_0[0], 4), np.round(optimal_lkg[0], 4), np.round(optimal_lkg[0] - optimal_lkg_0[0], 4)],
                  ['opt intensity KG', np.round(optimal_lkg_0[1], 4), np.round(optimal_lkg[1], 4), np.round(optimal_lkg[1] - optimal_lkg_0[1], 4)],
                  ['intensity LG/KG', np.round(optimal_lkg_0[0]/optimal_lkg_0[1], 4), np.round(optimal_lkg[0]/optimal_lkg[1], 4),
                    np.round((optimal_lkg[0]/optimal_lkg[1]) - (optimal_lkg_0[0]/optimal_lkg_0[1]), 4)]]            

  XY_opt_table = [['Variable', 'Benchmark', 'Policy', 'Diff (P-B)'],
                  ['opt intensity XZ', np.round(optimal_xyz_ratios_0[0], 4), np.round(optimal_xyz_ratios[0], 4), np.round(optimal_xyz_ratios[0] - optimal_xyz_ratios_0[0], 4)],
                  ['opt intensity YZ', np.round(optimal_xyz_ratios_0[1], 4), np.round(optimal_xyz_ratios[1], 4), np.round(optimal_xyz_ratios[1] - optimal_xyz_ratios_0[1], 4)]]
 
  quantities_table =   [['Variable', 'Benchmark', 'Policy', 'Diff (P-B)'],
                        ['Z', np.round(Z_q0[0], 4), np.round(Z_q[0], 4), np.round(Z_q[0] -  Z_q0[0], 4)],  
                        ['X', np.round(X_quant_0, 4), np.round(X_quant, 4), np.round(X_quant - X_quant_0, 4)],
                        ['Y', np.round(Y_quant_0, 4), np.round(Y_quant, 4), np.round(Y_quant - Y_quant_0, 4)],
                        ['G', np.round(Gq_sim, 4), np.round(G, 4), np.round(G - Gq_sim,4)],
                        ['LX' , np.round(LXq0, 4), np.round(LXq, 4), np.round(LXq - LXq0, 4)],
                        ['LY' , np.round(LYq0, 4), np.round(LYq, 4), np.round(LYq- LYq0, 4)],
                        ['LG' , np.round(LGq0, 4), np.round(LGq, 4), np.round(LGq - LGq0, 4)],
                        ['KX' , np.round(KXq0, 4), np.round(KXq, 4), np.round(KXq - KXq0, 4)],
                        ['KY' , np.round(KYq0, 4), np.round(KYq, 4), np.round(KYq - KYq0, 4)],
                        ['KG' , np.round(KGq0, 4), np.round(KGq, 4), np.round(KGq - KGq0, 4)],
                        ['F_Y', np.round(FYq0, 4), np.round(FYq, 4), np.round(FYq - FYq0, 4)]]
           
       
  alg_prices_table = [['Variable', 'Benchmark', 'Policy', 'Diff (P-B)'],
                      ['w', 1, w, w - 1],
                      ['algorithm price (r)', 1, np.round(inputs[0], 4), np.round(inputs[0] - 1,4)],
                      ['algorithm price (dT)', 1, np.round(inputs[1], 4), np.round(inputs[1] - 1, 4)],
                      ['algorithm price (s, fuel scalar)', 1 , np.round(s, 4), np.round(s - 1, 4)]]                   
  
  table_1 = [['Variable', 'w', 'r', 'v', 'dT'],
             ['dGov_Rev', (np.round(gov_rev,4)- np.round(gov_rev_0,4))/(r-1 + v-1 + dT),
              (np.round(gov_rev,4)- np.round(gov_rev_0,4))/(r-1),
              (np.round(gov_rev,4)- np.round(gov_rev_0,4))/(v-1),
              (np.round(gov_rev,4)- np.round(gov_rev_0,4))/(dT)],
             
             ['dGov_Exp', (np.round(gov_exp,4)- np.round(gov_exp_0,4))/(r-1 + v-1 + dT),
              (np.round(gov_exp,4)- np.round(gov_exp_0,4))/(r-1),
              (np.round(gov_exp,4)- np.round(gov_exp_0,4))/(v-1),
              (np.round(gov_exp,4)- np.round(gov_exp_0,4))/(dT)],
             
             ['dL_demand', (np.round(L_demand,4)- np.round(L_demand_0,4))/(r-1 + v-1 + dT),
              (np.round(L_demand,4)- np.round(L_demand_0,4))/(r-1),
              (np.round(L_demand,4)- np.round(L_demand_0,4))/(v-1),
              (np.round(L_demand,4)- np.round(L_demand_0,4))/(dT)],
             
              ['dK_demand', (np.round(K_demand,4)- np.round(K_demand_0,4))/(r-1 + v-1 + dT),
              (np.round(K_demand,4)- np.round(K_demand_0,4))/(r-1),
              (np.round(K_demand,4)- np.round(K_demand_0,4))/(v-1),
              (np.round(K_demand,4)- np.round(K_demand_0,4))/(dT)],
             
              ['dF_demand', (np.round(FYq,4)- np.round(FYq0,4))/(r-1 + v-1 + dT),
              (np.round(FYq,4)- np.round(FYq0,4))/(r-1),
              (np.round(FYq,4)- np.round(FYq0,4))/(v-1),
              (np.round(FYq,4)- np.round(FYq0,4))/(dT)],
             
              ['dGov_Rev/G', (np.round(gov_rev,4)- np.round(gov_rev_0,4))/(G*(r-1 + v-1 + dT)),
              (np.round(gov_rev,4)- np.round(gov_rev_0,4))/(G*(r-1)),
              (np.round(gov_rev,4)- np.round(gov_rev_0,4))/(G*(v-1)),
              (np.round(gov_rev,4)- np.round(gov_rev_0,4))/(G*(dT))],
             
             ['dGov_Exp/G', (np.round(gov_exp,4)- np.round(gov_exp_0,4))/(G*(r-1 + v-1 + dT)),
              (np.round(gov_exp,4)- np.round(gov_exp_0,4))/(G*(r-1)),
              (np.round(gov_exp,4)- np.round(gov_exp_0,4))/(G*(v-1)),
              (np.round(gov_exp,4)- np.round(gov_exp_0,4))/(G*(dT))],
             
             ['dL_demand/L0', (np.round(L_demand,4)- np.round(L_demand_0,4))/(L0*(r-1 + v-1 + dT)),
              (np.round(L_demand,4)- np.round(L_demand_0,4))/(L0*(r-1)),
              (np.round(L_demand,4)- np.round(L_demand_0,4))/(L0*(v-1)),
              (np.round(L_demand,4)- np.round(L_demand_0,4))/(L0*(dT))],
             
              ['dK_demand', (np.round(K_demand,4)- np.round(K_demand_0,4))/(K0*(r-1 + v-1 + dT)),
              (np.round(K_demand,4)- np.round(K_demand_0,4))/(K0*(r-1)),
              (np.round(K_demand,4)- np.round(K_demand_0,4))/(K0*(v-1)),
              (np.round(K_demand,4)- np.round(K_demand_0,4))/(K0*(dT))],
             
              ['dF_demand', (np.round(FYq,4)- np.round(FYq0,4))/(F0*(r-1 + v-1 + dT)),
              (np.round(FYq,4)- np.round(FYq0,4))/(F0*(r-1)),
              (np.round(FYq,4)- np.round(FYq0,4))/(F0*(v-1)),
              (np.round(FYq,4)- np.round(FYq0,4))/(F0*(dT))],
             ]
  
  
  table_2 = [['Variable', 'Benchmark', 'Policy', 'Diff (P-B)'],
           
           ['F_supply', np.round(F0*1, 4), np.round(F0*s, 4), np.round(F0*s - F0*1, 4)],
           ['F_demand', np.round(FYq0, 4), np.round(FYq, 4), np.round(FYq - FYq0, 4)],
           ['F_excess', np.round(F_excess_0*F0, 4), np.round(F_excess*F0, 4), np.round((F_excess*F0 -  F_excess_0*F0), 4)],
           
           ['L_supply', np.round(L0,4), np.round(L0,4), (np.round(L0,4)- np.round(L0,4))],
           ['L_demand', np.round(LXq0 + LYq0 + LGq0, 4), np.round(LXq + LYq + LGq, 4),
            np.round(((LXq + LYq + LGq) - (LXq0 + LYq0 + LGq0)), 4)],
           ['Labor Excess (D-S)', np.round(LXq0 + LYq0 + LGq0 - L0, 4),
            np.round(LXq + LYq + LGq - L0, 4),  np.round(((LXq + LYq + LGq - L0)- (LXq0 + LYq0 + LGq0 - L0)), 4)],
           

           ['K_supply', np.round(K0,4), np.round(K0,4), (np.round(K0,4)- np.round(K0,4))],
           ['K_demand', np.round(KXq0 + KYq0 + KGq0, 4), np.round(KXq + KYq + KGq, 4), 
            np.round(((KXq + KYq + KGq) - (KXq0 + KYq0 + KGq0)), 4)],
           ['Capital Excess(D-S)',  np.round(KXq0 + KYq0 + KGq0 - K0, 4),np.round(KXq + KYq + KGq - K0, 4),
              np.round(((KXq + KYq + KGq - K0) - (KXq0 + KYq0 + KGq0 - K0)), 4)],
          
           ['Gov Revenue Supplied', np.round(gov_rev_0, 4), np.round(gov_rev, 4), np.round((gov_rev - gov_rev_0), 4)],
           ['Gov Expenditure', np.round(gov_exp_0, 4), np.round(gov_exp, 4), np.round((gov_exp - gov_exp_0), 4)],
           ['Gov Excess (rev-exp)',np.round(gov_rev_0 - gov_exp_0, 4), np.round(gov_rev - gov_exp, 4), 
            np.round(((gov_rev - gov_exp) - (gov_rev_0 - gov_exp_0)), 4)],
           
           ['Walras Sum', np.round(walras_0,4), np.round(walras, 4), np.round(walras - walras_0, 4)],
           ['Fuel Excess as Ratio (D-S)', np.round(F_excess_0, 4),
            np.round(F_excess, 4),  np.round((F_excess_0) - (F_excess), 4)],
           ['Labor Excess as Ratio (D-S)', np.round(L_excess_0, 4),
            np.round(L_excess, 4),  np.round((L_excess_0)- (L_excess), 4)],
           
         
            ['Capital Excess as Ratio (D-S)', np.round(K_excess_0, 4),
            np.round(K_excess, 4),  np.round((K_excess_0)- (K_excess), 4)],
           ['Gov Excess as Ratio (D-S)', np.round(gov_excess_0, 4),
            np.round(gov_excess, 4),  np.round((gov_excess)- (gov_excess_0), 4)]]
          
          
           
          
           
          

  table_3 = [['Variable', 'Def'], ['Total Income', 'HH Labor Inc + HH Capital Inc + HH Fuel Inc - Transfer'],
              ['Total Expenditures', 'Xq (supplied) * p_X + Yq (supplied) * p_Y']]

  EXCESS_TABLE = [['Variable', 'Benchmark', 'Policy', 'Diff (P-B)'],
                 ['F_excess', np.round(F_excess_0*F0, 4), np.round(F_excess*F0, 4), np.round((F_excess*F0 -  F_excess_0*F0), 4)],
                 ['Labor Excess (D-S)', np.round(L_demand_0 - L0, 4), np.round(L_demand - L0, 4),  np.round(((L_demand - L0)- (L_demand_0 - L0)), 4)],
                 ['Capital Excess(D-S)',  np.round(K_demand_0 - K0, 4),np.round(K_demand - K0, 4),
                    np.round(((K_demand - K0) - (K_demand_0 - K0)), 4)],
                 ['Gov Excess (rev-exp)',np.round(gov_rev_0 - gov_exp_0, 4), np.round(gov_rev - gov_exp, 4), 
                    np.round(((gov_rev - gov_exp) - (gov_rev_0 - gov_exp_0)), 4)],
                  ['sum excess demands', np.round(sum_excess_demands_0,4),
                   np.round(sum_excess_demands, 4),np.round(sum_excess_demands - sum_excess_demands_0, 4)],
                 ['Walras Sum', np.round(walras_0,4), np.round(walras, 4), np.round(walras - walras_0, 4)]]


  taxes_income_table = [['Variable', 'Benchmark', 'Policy', 'Diff (P-B)'],
                         ['Fuel Price', 1, np.round(v + tF, 4), np.round((v + tF) - 1, 4)],
                         ['Fuel Elasticity', "NA", np.round(fuel_elasticity, 4)],
                         ['HH Labor Income', np.round(Z_q0[1], 4), np.round(Z_q[1], 4), np.round(Z_q[1] - Z_q0[1], 4)],
                         ['HH Capital Income', np.round(Z_q0[2], 4), np.round(Z_q[2], 4), np.round(Z_q[2] - Z_q0[2], 4)],
                         ['HH Fuel Income', np.round(Z_q0[4], 4), np.round(Z_q[4], 4), np.round(Z_q[4] - Z_q0[4], 4)],
                         ['HH Transfer', np.round(Z_q0[3], 4), np.round(Z_q[3], 4), np.round(Z_q[3] - Z_q0[3], 4)],
                         ['Total Income', np.round(total_inc_0, 4), np.round(total_inc, 4), np.round(total_inc - total_inc_0, 4)],
                         ['Labor taxes paid', np.round(L_taxes_0, 4), np.round(L_taxes, 4), np.round(L_taxes - L_taxes_0, 4)],
                         ['Capital taxes paid', np.round(K_taxes_0, 4), np.round(K_taxes, 4), np.round(K_taxes - K_taxes_0, 4)],
                         ['Fuel Taxes paid', np.round(F_tax_0, 4), np.round(F_tax, 4), np.round(F_tax - F_tax_0, 4)],
                         ['Gov Revenue Supplied', np.round(gov_rev_0, 4), np.round(gov_rev, 4), np.round((gov_rev - gov_rev_0), 4)], 
                         ['Gov Expenditure', np.round(gov_exp_0, 4), np.round(gov_exp, 4), np.round((gov_exp - gov_exp_0), 4)],
                         ['X expenditures', np.round(X_exp_0, 4), np.round(X_exp, 4), np.round(X_exp - X_exp_0, 4)],
                         ['Y expenditures', np.round(Y_exp_0, 4), np.round(Y_exp, 4), np.round(Y_exp - Y_exp_0, 4)],
                         ['Total Expenditures', np.round(total_exp_0, 4), np.round(total_exp, 4), np.round(total_exp -  total_exp_0, 4)]]
           

  print(tabulate(price_table))
  print(tabulate(alg_prices_table))
  print(tabulate(taxes_income_table))
  print(tabulate(quantities_table))
  print(tabulate(EXCESS_TABLE))

  return F_excess**2 + K_excess**2 +  gov_excess**2


#w = 1. #wage rate
#r = 1. #capital rate
v = 1.0 #price of fuel
ty = 0 #ad valorem tax on good Y
tx = 0
tF = 0.1 #emissions tax (unit tax)

dM = 1 #multiplicative factor applied to labor and capital tax
E_lim = 79.5




res_1 = least_squares(sim_inner, np.array([1.0 ,1, 1.0]), args = (v, ty, tx, tF), ftol = 1e-11, xtol=None, gtol = None, max_nfev = 300, verbose = 2, diff_step=0.001) 
res_1



with open('alg_output.txt', 'w') as f:
    f.write(cap.stdout)

files.download('alg_output.txt')

"""$$L_{Xq} = \frac{L_X}{(1+\tau_L)}$$
\
$$K_{Xq}  = \frac{K_X}{(1+\tau_K)}$$

\

$$w_{tax} = w(1 + \tau_L)$$
\

$$r_{tax} = r(1 + \tau_K)$$
\

$$X_{0q} = L_{Xq} + K_{Xq} $$
\
$$\gamma_Xp_XX_{0q} = w_{tax}L_{Xq}+ r_{tax}K_{Xq}$$

\

$$p_X = \gamma_X^{\frac{\sigma_X}{(\sigma_X - 1)}}[\alpha_{KX}^{\sigma_X}r_{tax}^{1-\sigma_X} + \alpha_{LX}^{\sigma_X}w_{tax}^{1-\sigma_X}]^{\frac{1}{(1-\sigma_X)}}$$


"""
